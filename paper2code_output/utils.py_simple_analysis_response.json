[{"text": " Here's the logic analysis for the `utils.py` file, which contains utility functions for logging metrics, handling configuration, and other miscellaneous tasks:\n\n```python\nimport yaml\nimport logging\nfrom typing import Any, Dict, Union\n\n# Configuration handling\ndef load_config(config_path: str) -> Dict[str, Any]:\n    \"\"\"\n    Loads the configuration from a YAML file.\n    \n    Args:\n        config_path (str): The path to the configuration file.\n    \n    Returns:\n        Dict[str, Any]: The loaded configuration.\n    \"\"\"\n    with open(config_path, 'r') as file:\n        config = yaml.safe_load(file)\n    return config\n\n# Logging setup\ndef setup_logging(log_file: str) -> None:\n    \"\"\"\n    Sets up the logging configuration.\n    \n    Args:\n        log_file (str): The path to the log file.\n    \"\"\"\n    logging.basicConfig(\n        filename=log_file,\n        level=logging.INFO,\n        format='%(asctime)s - %(levelname)s - %(message)s'\n    )\n    console = logging.StreamHandler()\n    console.setLevel(logging.DEBUG)\n    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n    console.setFormatter(formatter)\n    logging.getLogger('').addHandler(console)\n\n# Metric logging\ndef log_metrics(metrics: Dict[str, float], log_file: str) -> None:\n    \"\"\"\n    Logs the given metrics to the specified file.\n    \n    Args:\n        metrics (Dict[str, float]): The metrics to log.\n        log_file (str): The path to the log file.\n    \"\"\"\n    with open(log_file, 'a') as file:\n        for metric_name, metric_value in metrics.items():\n            file.write(f\"{metric_name}: {metric_value}\\n\")\n    logging.info(f\"Metrics logged: {metrics}\")\n\n# Risk level configuration\ndef get_risk_configuration(config: Dict[str, Any], risk_level: str) -> float:\n    \"\"\"\n    Retrieves the risk level configuration from the given config.\n    \n    Args:\n        config (Dict[str, Any]): The configuration dictionary.\n        risk_level (str): The risk level identifier.\n    \n    Returns:\n        float: The risk level threshold.\n    \"\"\"\n    return config['evaluation']['ETCU_risk_levels'].get(risk_level, 0.0)\n\n# Example usage\nif __name__ == \"__main__\":\n    # Load configuration\n    config = load_config('config.yaml')\n    \n    # Setup logging\n    setup_logging('application.log')\n    \n    # Example metrics\n    metrics = {\n        'smECE': 0.05,\n        'ETCU': 0.8\n    }\n    \n    # Log metrics\n    log_metrics(metrics, 'metrics_log.txt')\n    \n    # Get risk configuration\n    low_risk_threshold = get_risk_configuration(config, 'low')\n    print(f\"Low risk threshold: {low_risk_threshold}\")\n```\n\n### Explanation of the Utility Functions\n\n1. **load_config**: This function reads the configuration from a YAML file and returns it as a dictionary. This configuration is used to set up various parameters for data preprocessing, model training, and evaluation.\n\n2. **setup_logging**: This function sets up the logging configuration to log messages with a specific format to both a file and the console. This is useful for debugging and tracking the execution of the program.\n\n3. **log_metrics**: This function logs the given metrics to a specified file. Each metric is written as a separate line, and the function also logs the metrics to the console for immediate visibility.\n\n4. **get_risk_configuration**: This function retrieves the risk level configuration from the given configuration dictionary. It is used to get the threshold for the Expected Tool-Calling Utility (ETCU) corresponding to a specific risk level.\n\nThese functions are designed to be flexible and reusable across different parts of the application, making it easier to manage configurations and logging."}]